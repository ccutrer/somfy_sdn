#!/usr/bin/env ruby

require 'curses'
require 'somfy_sdn'


sdn = SDN::Client.new(ARGV[0])

if ARGV[1]
  addr = SDN::Message.parse_address(ARGV[1])
else
  puts "Discovering motor..."
  message = sdn.ensure(SDN::Message::GetNodeAddr.new)
  puts "Found #{message.node_type}"
  addr = message.src
end

puts "Preparing to provision motor #{SDN::Message.print_address(addr)}"

message = sdn.ensure(SDN::Message::GetNodeLabel.new(addr), SDN::Message::PostNodeLabel)

node_type = message.node_type

print "Motor is currently labeled '#{message.label}'; what would you like to change it to (blank to leave alone)? "
new_label = STDIN.gets

unless new_label == "\n"
  new_label.strip!
  klass = node_type == :st50ilt2 ? SDN::Message::ILT2::SetNodeLabel : SDN::Message::SetNodeLabel
  sdn.ensure(klass.new(addr, new_label))
end

class Provisioner
  attr_reader :win, :sdn, :addr

  def initialize(win, sdn, addr)
    @sdn = sdn
    @addr = addr
    @win = win
    @reversed = false

    win.keypad = true

    win.addstr(<<-INSTRUCTIONS)
  Move the motor. Keys:
  Esc  stop movement
  \u2191    go to upper limit
  \u2193    go to lower limit
  \u2190    jog up 10 pulses
  \u2192    jog down 10 pulses
  u    set upper limit at current position
  l    set lower limit at current position
  r    reverse motor
  R    reverse motor (but leave position alone)
  q    quit
    INSTRUCTIONS

    refresh
  end

  def close
    Curses.close_screen
  end

  def process
    loop do
      char = win.getch
      case char
      when 27 # Esc
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :stop))
        refresh
      when Curses::Key::UP
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :up_limit))
        wait_for_stop
      when Curses::Key::DOWN
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :down_limit))
        wait_for_stop
      when Curses::Key::LEFT
        if @pos < 10
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit + 10 - @pos, 10))
          refresh
        end
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :jog_up_pulses, 10))
        refresh
      when Curses::Key::RIGHT
        if @limit - @pos < 10
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @pos + 10, @pos))
          refresh
        end
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :jog_down_pulses, 10))
        refresh
      when 'u'
        sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit - @pos, 0))
        refresh
      when 'l'
        sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @pos, @pos))
        refresh
      when 'r'
        @reversed = !@reversed
        sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit, @limit - @pos))
        refresh
      when 'R'
        @reversed = !@reversed
        sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit, @pos))
        refresh
      when 'q'
        break
      end
    end
  end

  def wait_for_stop
    win.setpos(13, 0)
    win.addstr("Moving...\n")
    loop do
      win.nodelay = true
      if win.getch == 27 # Esc
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :stop))
      end
      sdn.send(SDN::Message::ILT2::GetMotorPosition.new(addr))
      sdn.receive do |message|
        next unless message.is_a?(SDN::Message::ILT2::PostMotorPosition)
        last_pos = @pos
        @pos = message.position_pulses
        win.setpos(14, 0)
        win.addstr("Position: #{@pos}\n")

        if last_pos == @pos
          win.setpos(13, 0)
          win.addstr("\n")
          win.nodelay = false
          refresh
          return
        end
      end
      sleep 0.1
      
    end
  end

  def refresh
    pos = sdn.ensure(SDN::Message::ILT2::GetMotorPosition.new(addr), SDN::Message::ILT2::PostMotorPosition)
    settings = sdn.ensure(SDN::Message::ILT2::GetMotorSettings.new(addr), SDN::Message::ILT2::PostMotorSettings)
    @pos = pos.position_pulses
    @limit = settings.limit

    win.setpos(14, 0)
    win.addstr("Position: #{@pos}\n")
    win.addstr("Limit: #{@limit}\n")
    win.addstr("Reversed: #{@reversed}\n")
  end

  def reversed_int
    @reversed ? 1 : 0
  end
end

begin
  Curses.init_screen
  Curses.noecho
  Curses.crmode
  Curses.nonl
  Curses.curs_set(0)

  p = Provisioner.new(Curses.stdscr, sdn, addr)
  p.process
ensure
  p.close
end
