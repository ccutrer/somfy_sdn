#!/usr/bin/env ruby

require 'curses'
require 'somfy_sdn'


sdn = SDN::Client.new(ARGV[0])

if ARGV[1]
  addr = SDN::Message.parse_address(ARGV[1])
else
  puts "Discovering motor..."
  message = sdn.ensure(SDN::Message::GetNodeAddr.new)
  puts "Found #{message.node_type}"
  addr = message.src
end

puts "Preparing to provision motor #{SDN::Message.print_address(addr)}"

message = sdn.ensure(SDN::Message::GetNodeLabel.new(addr), SDN::Message::PostNodeLabel)

node_type = message.node_type
ns = node_type == :st50ilt2 ? SDN::Message::ILT2 : SDN::Message

print "Motor is currently labeled '#{message.label}'; what would you like to change it to (blank to leave alone)? "
new_label = STDIN.gets

unless new_label == "\n"
  new_label.strip!
  sdn.ensure(ns::SetNodeLabel.new(addr, new_label))
end

# make sure some limits exist
unless ns == SDN::Message::ILT2
  limits = sdn.ensure(SDN::Message::GetMotorLimits.new(addr))
  if limits.up_limit.nil? || limits.down_limit.nil?
    sdn.ensure(SDN::Message::SetMotorLimits.new(addr, :delete, :up))
    sdn.ensure(SDN::Message::SetMotorLimits.new(addr, :delete, :down))
    sdn.ensure(SDN::Message::SetMotorLimits.new(addr, :current_position, :up))
    sdn.ensure(SDN::Message::SetMotorLimits.new(addr, :specified_position, :down, 500))
  end
end

class Provisioner
  attr_reader :win, :sdn, :addr, :ns

  def initialize(win, sdn, addr, ns)
    @sdn = sdn
    @addr = addr
    @win = win
    @ns = ns
    @reversed = false
    @pulse_count = 10

    win.keypad = true


    print_help
    refresh
  end

  def close
    Curses.close_screen
  end

  def process
    loop do
      char = win.getch
      case char
      when 27 # Esc
        stop
        refresh
      when Curses::Key::UP
        if ilt2?
          sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :up_limit))
        else
          sdn.ensure(SDN::Message::MoveTo.new(addr, :up_limit))
        end
        wait_for_stop
      when Curses::Key::DOWN
        if ilt2?
          sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :down_limit))
        else
          sdn.ensure(SDN::Message::MoveTo.new(addr, :down_limit))
        end
        wait_for_stop
      when Curses::Key::LEFT
        if @pos < @pulse_count
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit + @pulse_count - @pos, @pulse_count))
          refresh
        end
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :jog_up_pulses, @pulse_count))
        wait_for_stop
      when Curses::Key::RIGHT
        if @limit - @pos < @pulse_count
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @pos + @pulse_count, @pos))
          refresh
        end
        sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :jog_down_pulses, @pulse_count))
        wait_for_stop
      when 'u'
        if ilt2?
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit - @pos, 0))
        else
          sdn.ensure(SDN::Message::SetMotorLimits.new(addr, :current_position, :up))
        end
        refresh
      when 'l'
        if ilt2?
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @pos, @pos))
        else
          sdn.ensure(SDN::Message::SetMotorLimits.new(addr, :current_position, :down))
        end
        refresh
      when 'r'
        @reversed = !@reversed
        if ilt2?
          sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit, @limit - @pos))
        else
          sdn.ensure(SDN::Message::SetMotorDirection.new(addr, @reversed ? :reversed : :standard))
        end
        refresh
      when 'R'
        next unless ilt2?
        @reversed = !@reversed
        sdn.ensure(SDN::Message::ILT2::SetMotorSettings.new(addr, reversed_int, @limit, @pos))
        refresh
      when '<'
        @pulse_count /= 2 if @pulse_count > 5
        print_help
      when '>'
        @pulse_count *= 2
        print_help
      when 'q'
        break
      end
    end
  end

  def print_help
    win.setpos(0, 0)
    win.addstr(<<-INSTRUCTIONS)
Move the motor. Keys:
Esc  stop movement
\u2191    go to upper limit
\u2193    go to lower limit
\u2190    jog up #{@pulse_count} pulses
\u2192    jog down #{@pulse_count} pulses
>    increase jog size
<    decrease jog size
u    set upper limit at current position
l    set lower limit at current position
r    reverse motor
    INSTRUCTIONS

    if ilt2?
      win.addstr("R    reverse motor (but leave position alone)\n")
    end
    win.addstr("q    quit\n")
  end
  
  def wait_for_stop
    win.setpos(13, 0)
    win.addstr("Moving...\n")
    loop do
      win.nodelay = true
      stop if win.getch == 27 # Esc
      sdn.send(ns::GetMotorPosition.new(addr))
      sdn.receive do |message|
        next unless message.is_a?(ns::PostMotorPosition)
        last_pos = @pos
        @pos = message.position_pulses
        win.setpos(14, 0)
        win.addstr("Position: #{@pos}\n")

        if last_pos == @pos
          win.setpos(13, 0)
          win.addstr("\n")
          win.nodelay = false
          refresh
          return
        end
      end
      sleep 0.1
      
    end
  end

  def refresh
    pos = sdn.ensure(ns::GetMotorPosition.new(addr), ns::PostMotorPosition)
    @pos = pos.position_pulses
    if ilt2?
      settings = sdn.ensure(SDN::Message::ILT2::GetMotorSettings.new(addr), SDN::Message::ILT2::PostMotorSettings)
      @limit = settings.limit
    else
      limits = sdn.ensure(SDN::Message::GetMotorLimits.new(addr), SDN::Message::PostMotorLimits)
      @limit = limits.down_limit
      direction = sdn.ensure(SDN::Message::GetMotorDirection.new(addr), SDN::Message::PostMotorDirection)
      @reversed = direction.direction == :reversed
    end

    win.setpos(14, 0)
    win.addstr("Position: #{@pos}\n")
    win.addstr("Limit: #{@limit}\n")
    win.addstr("Reversed: #{@reversed}\n")
  end

  def stop
    if ilt2?
      sdn.ensure(SDN::Message::ILT2::SetMotorPosition.new(addr, :stop))
    else
      sdn.ensure(SDN::Message::Stop.new(addr))
    end
  end

  def ilt2?
    ns == SDN::Message::ILT2
  end

  def reversed_int
    @reversed ? 1 : 0
  end
end

begin
  Curses.init_screen
  Curses.noecho
  Curses.crmode
  Curses.nonl
  Curses.curs_set(0)
  win = Curses.stdscr

  p = Provisioner.new(win, sdn, addr, ns)
  p.process
rescue => e
  win.setpos(0, 0)
  win.addstr(e.inspect)
  win.addstr("\n")
  win.addstr(e.backtrace.join("\n"))
  win.refresh
  sleep 10
ensure
  p.close
end
